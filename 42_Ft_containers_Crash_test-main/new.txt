// template <class InputIterator>
		// void	assign(InputIterator first, InputIterator last, typename ft::enable_if<!ft::is_integral<InputIterator>::value>::type* = 0)
		// {
		// 	clear();
		// 	difference_type __ns = std::distance(first, last);
		// 	if (__ns < 0)
		// 		throw("invalid range specified");
		// 	// std::assert(__ns >= 0, "invalid range specified");
		// 	const size_t __n = static_cast<size_type>(__ns);
		// 	if (__n)
		// 	{
		// 		if (__n > capacity())
		// 		{
		// 			// __vdeallocate();
		// 			deallocate_v();
		// 			_start = _alloc.allocate(__n);
		// 		}
		// 		_end = _start;
		// 		for (;first != last; ++first, ++_end)
		// 			_alloc.construct(_end, *first);
		// 		_cap = _end;
				
		// 		// __construct_at_end(__first, __last);
		// 	}
	}
		// {
		// 	clear();
		// 	LOG("AGDSG")
		// 	for (; first != last; ++first)
		// 		push_back(*first);
		// }

		//  replaces the contents with count copies of value value  //
		// void	assign(size_type __n, const value_type& __u)
		// {
		// 	LOG("KK")
		// 	if (__n <= capacity())
		// 	{
		// 		size_type __s = size();
		// 		std::fill_n(this->_start, std::min(__n, __s), __u);
		// 		if (__n > __s)
		// 			// construct_range(_end, __n - __s, __u);
		// 			for (size_type i = 0 ; i < __n - __s; ++i, ++_end)
		// 				_alloc.construct(_end, __u);
		// 		else
		// 			for (size_type i = __s - __n; i > 0; --i, --_end)
		// 				_alloc.destroy(_end);
		// 			// this->__destruct_at_end(this->__begin_ + __n);
		// 	}
			// else
			// {
			// 	// __vdeallocate();
			// 	deallocate_v();
			// 	_start = _alloc.allocate(static_cast<size_type>(__n));
			// 	// __vallocate(__recommend(static_cast<size_type>(__n)));
			// 	_end = _start;
			// 	for (size_type i = 0; i < __n; ++i, ++_end)
			// 		_alloc.construct(_end, __u);
			// 	_cap = _end;
			// }
			// __invalidate_all_iterators();
		}
